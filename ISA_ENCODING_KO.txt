이 문서는 어셈블리 형태 명령어가 2바이트(16비트) ‘실행용’ 인코딩으로 매핑되는 최신 규칙을 정리한 사양입니다.
본 사양은 어셈블러(assemble_program)와 CPU(ISA 모드)가 사용하는 실제 인코딩을 설명하며,
IR(F1~F12) 표시 또한 이 실행 인코딩 바이트를 그대로 점등합니다.

1) 개요
- 2바이트(16비트) 프레임 기반 인코딩을 사용합니다.
- PC는 “ISA 프레임 인덱스(명령 단위)”로 동작하며, 기본적으로 +1씩 증가합니다.
  (라벨 전용 줄은 어셈블 단계에서 제거되고, 라벨은 ISA 프레임 주소로 매핑됩니다.)
- 인코딩 포맷(공통):
  • Byte0 = [OP(상위 4비트) | DST(하위 4비트)]
  • Byte1 = ARG(하위 8비트)
- 해석 규칙은 OP에 의해 결정되며, Byte1(ARG)은 즉시값·상대오프셋·SRC ID·모드 등에 사용됩니다.
- 변수 이름은 4비트 ID로 맵핑합니다(표 2 참조).

2) 변수(레지스터) ID 맵
- 4비트(0~15) ID로 고정. 프로젝트 기본값(변경 가능):
  q=0x0, w=0x1, e=0x2, r=0x3, a=0x4, s=0x5, d=0x6, z=0x7, x=0x8

3) OP 코드(4비트) 배정표(실행 인코딩)
- OP는 상위 4비트에 배치됩니다.
  0x0: NOP / EXT(프리픽스)  [DST=0 → NOP, DST≠0 → EXT]
  0x1: HALT
  0x2: MOV   (ARG=SRC 변수ID)
  0x3: MOVI  (ARG=IMM8)
  0x4: ADD   (ARG=SRC 변수ID)
  0x5: ADDI  (ARG=IMM8)
  0x6: SUB   (ARG=SRC 변수ID)
  0x7: SUBI  (ARG=IMM8)
  0x8: AND   (ARG=SRC 변수ID)
  0x9: OR    (ARG=SRC 변수ID)
  0xA: XOR   (ARG=SRC 변수ID)
  0xB: SHIFT (ARG bit0: 0=SHL, 1=SHR)
  0xC: NEG   (단항 부정: dst ← 0 - dst)
  0xD: CMP   (레지스터형; 즉시형은 EXT 프리픽스 사용)
  0xE: JMP   (ARG=rel8, PC상대)
  0xF: BR    (DST=조건 nibble, ARG=rel8, PC상대)

4) 분기/점프 인코딩(실행)
- BR(OP=0xF): DST=조건 코드(4비트), ARG=rel8(서명 8비트, 다음 프레임 기준 PC상대)
- JMP(OP=0xE): ARG=rel8(서명 8비트, 다음 프레임 기준 PC상대)
- 조건 코드 nibble(예):
  • 0x0: BEQ(Z==1)  • 0x1: BNE(Z==0)
  • 0x2: BPL(N==0)  • 0x3: BMI(N==1)
  • 0x4: BVC(V==0)  • 0x5: BVS(V==1)
  • 0x6: BCC(V==0)  • 0x7: BCS(V==1)

5) 오퍼랜드 규칙(요약)
- 공통: DST nibble=대상 변수 ID(필요 없는 경우 0), ARG byte=OP별 의미
- MOV/ADD/SUB/AND/OR/XOR/CMP(레지스터형): ARG[3:0]=SRC 변수 ID
- MOVI/ADDI/SUBI: ARG=IMM8(2의 보수, signed)
- CMPI: EXTI(프리픽스)로 IMM8을 먼저 전송 후, 바로 이어지는 CMP를 해석할 때 그 IMM을 두 번째 피연산자로 사용
- SHIFT: ARG bit0=0→SHL, 1→SHR(그 외 비트=0)
- NEG: ARG=0(무시)
- BR/JMP: ARG=rel8(서명 8비트), 다음 프레임 기준 PC상대

6) 예시(헥사 덤프 포함)
표기: “B0 B1  ; 설명”  (B0/B1은 16진 2자리)

6.1 대입/이동
  a = 5          → MOVI a, #5
    B0=0x34, B1=0x05    ; OP=3(MOVI), DST=a(0x4), IMM8=0x05

  a = -1         → MOVI a, #-1
    B0=0x34, B1=0xFF    ; -1의 8비트 표현

  d = a          → MOV d, a
    B0=0x26, B1=0x04    ; OP=2(MOV), DST=d(0x6), SRC=a(0x4)

6.2 산술(레지스터-레지스터/즉시)
  a = a + 1      → ADDI a, #1
    B0=0x54, B1=0x01    ; OP=5(ADDI), DST=a

  a = a + d      → ADD a, d
    B0=0x44, B1=0x06    ; OP=4(ADD),  DST=a, SRC=d

  x = x - 1      → SUBI x, #1
    B0=0x78, B1=0x01    ; OP=7(SUBI), DST=x(0x8)

  x = x - a      → SUB x, a
    B0=0x68, B1=0x04    ; OP=6(SUB),   DST=x, SRC=a

6.3 비트 연산
  d = d & a      → AND d, a
    B0=0x86, B1=0x04

  d = d | a      → OR d, a
    B0=0x96, B1=0x04

  d = d ^ a      → XOR d, a
    B0=0xA6, B1=0x04

6.4 시프트/비교
  SHL a          → SHL a
    B0=0xB4, B1=0x00

  SHR a          → SHR a
    B0=0xB4, B1=0x01   ; SHIFT, dir=1

  CMP a, d       → CMP a, d    ; a-d 결과로 Z/N/V/C 갱신(결과 저장 없음)
    B0=0xD4, B1=0x06

  CMPI a, #-3    → EXTI + CMP a,#imm
    B0=0x0E, B1=0xFD    ; EXTI(IMM8=-3)
    B0=0xD4, B1=0x00    ; CMP a,#imm (IMM은 직전 EXTI에서 래치)

6.5 분기/점프(실행 인코딩)
  BEQ loop       → DST=cond, ARG=rel8
    B0=0xF0, B1=0xFE    ; cond=0x0(BEQ), rel8=-2(예)

  JMP somewhere  → ARG=rel8
    B0=0xE0, B1=0xFB    ; rel8=-5(예)

  HALT           → 종료
    B0=0x10, B1=0x00

7) IR(F1~F12) LED 표시 매핑(실행 인코딩 그대로 표시)
- 목적: 2바이트(16비트)를 12키로 표현. OP/DST는 1비트(ON/OFF), ARG는 2비트 쌍(4색)으로 표시.
- F1~F4: OP 니블 4비트(상→하) = OP[3]→F1, OP[2]→F2, OP[1]→F3, OP[0]→F4
- F5~F8: DST 니블 4비트(상→하) = DST[3]→F5 … DST[0]→F8
- F9~F12: ARG 바이트 4쌍(2비트×4) = ARG[7:6]→F9 … ARG[1:0]→F12
- 분기(OP=0xF)의 조건 코드는 DST 니블에 표시됩니다(섹션 4 참조). EXTI 프레임(OP=0x0, DST=0xE)은 그대로 점등됩니다.

간단 예시(표시 관점):
- ADDI a,#1  → OP=0x5(0101), DST=a=0x4(0100), ARG=0x01(0000 0001)
  • F1..F4 = 0,1,0,1  • F5..F8 = 0,1,0,0  • F9..F12 = 00,00,00,01(마지막 F12=Green)


8) 프로그램 어드레싱/실행(현재 구현)
- 어셈블러는 고수준 소스를 ‘ISA 프레임 배열’로 전개하고, 라벨은 해당 프레임 인덱스로 매핑합니다.
- PC는 ISA 프레임 인덱스로 동작합니다. 분기/점프는 rel8(서명)으로 PC를 갱신합니다.
- EXTI(프리픽스)가 있는 경우: EXTI → IMM 프레임을 먼저 소비하고, 바로 이어지는 본 명령(CMP 등)에 적용합니다.
- CPU는 각 프레임의 (OP,DST,ARG)를 IR(F1~F12)에 점등 후 복호화·실행합니다.

9) 미묘한 부분/주의점
- 즉시값은 8비트 래핑(2의 보수). 예: 130 → 0x82 → 실행 시 -126으로 보일 수 있음.
- CMP/CMPI는 결과 저장 없이 Z/N/V/C만 갱신. CMPI는 EXTI로 IMM을 보내고, 다음 CMP 프레임에 적용.
- SUB/CMPI에서 C는 no-borrow 정의(빌림 없으면 1, 빌림 발생 시 0).
- SHIFT는 단일 OP(0xB)에서 ARG bit0로 방향을 구분. NEG(0xC)는 단항 부정.
- IR 복호화는 안정화를 위해 다중 샘플/캘리브레이션을 사용할 수 있습니다(코드 참조: utils/ir_indicator.py).

10) 짧은 데모 프로그램(실행 인코딩 예시)
소스:
  a = -1
  a = a + 1
  x = 0
  x = x - 1
  HALT

실행 인코딩:
  MOVI a,#-1  → B0=34, B1=FF
  ADDI a,#1   → B0=54, B1=01
  MOVI x,#0   → B0=38, B1=00
  SUBI x,#1   → B0=78, B1=01
  HALT        → B0=10, B1=00

11) 향후 확장 여지
- EXT 프리픽스를 통해 다양한 확장(예: 16비트 즉시, 어드레싱 모드, 서브옵코드)을 통일적으로 도입 가능
- 메모리 접근, I/O, 시스템 기능을 위한 OP 공간 확장

본 사양은 현재 리포지토리의 코드와 일치합니다(표시용 ENC + IR 점등).
향후 실제 어셈블러/로더를 도입할 때 분기 오프셋/절대주소 등 세부 포맷은 달라질 수 있습니다.
