이 문서는 현재 어셈블리 형태 명령어가 2바이트(16비트) 기계어로 매핑되는 규칙을 사람 친화적으로 정리한 사양 초안입니다.
본 문서는 코드에 즉시 적용된 것이 아니라, 향후 어셈블러/로더 구현과 IR(명령어 레지스터) LED 표시 정책의 근거 자료로 사용됩니다.

1) 개요
- 정폭 2바이트(16비트) 인스트럭션.
- PC는 바이트 주소로 동작하며, 기본적으로 +2씩 증가합니다(분기/점프 시 덮어씀).
- 인스트럭션 형식(단일 포맷):
  • Byte0 = [OP(상위 4비트) | DST(하위 4비트)]
  • Byte1 = ARG(하위 8비트)
- 해석 규칙은 OP에 의해 결정되며, Byte1(ARG)은 즉시값/소스 레지스터/분기 오프셋/절대 주소 등으로 역할이 달라집니다.
- 변수 이름은 4비트 ID로 맵핑합니다(표 2 참조).

2) 변수(레지스터) ID 맵
- 4비트(0~15) ID로 고정. 프로젝트 기본값(변경 가능):
  q=0x0, w=0x1, e=0x2, r=0x3, a=0x4, s=0x5, d=0x6, z=0x7, x=0x8

3) OP 코드(4비트) 배정표
- OP는 상위 4비트에 배치됩니다.
  0x0: NOP(또는 기타 표시 전용 마이크로옵)
  0x1: HALT
  0x2: MOV  (Byte1=SRC-레지스터ID)
  0x3: MOVI (Byte1=IMM8)
  0x4: ADD  (Byte1=SRC)
  0x5: ADDI (Byte1=IMM8)
  0x6: SUB  (Byte1=SRC)
  0x7: SUBI (Byte1=IMM8)
  0x8: AND  (Byte1=SRC)
  0x9: OR   (Byte1=SRC)
  0xA: XOR  (Byte1=SRC)
  0xB: SHL  (Byte1=0)
  0xC: SHR  (Byte1=0)
  0xD: CMP/CMPI (Byte1=SRC 또는 IMM8)
  0xE: JMP  (Byte1=ABS8: 절대 바이트 주소)
  0xF: BR   (분기군, Byte1=REL8: PC 상대 오프셋)

4) 분기군(0xF)의 조건 코드(DST 하위 4비트)
- DST nibble은 아래 조건 코드를 담습니다.
  0x0: BEQ (Z=1)
  0x1: BNE (Z=0)
  0x2: BPL (N=0)
  0x3: BMI (N=1)
  0x4: BVC (V=0)
  0x5: BVS (V=1)
  0x6: BCC (C=0)
  0x7: BCS (C=1)
  0x8~0xF: 예약

5) 오퍼랜드 규칙(요약)
- 공통: Byte0 하위 4비트(DST)는 ‘대상 레지스터/변수 ID’ 또는 ‘분기 조건 코드’를 담습니다.
- 공통: Byte1(ARG)는 8비트이며, 상황에 따라 아래와 같이 해석됩니다.
  • MOV/ADD/SUB/AND/OR/XOR/CMP: SRC = 4비트 레지스터 ID(하위 4비트 사용, 상위 4비트는 0)
  • MOVI/ADDI/SUBI/CMPI: IMM8 = 2의 보수(signed) 표현(예: -1 → 0xFF)
  • BR(분기): REL8 = 다음 인스트럭션 주소(PC+2) 기준의 signed 오프셋
  • JMP: ABS8 = 절대 바이트 주소(0~255)
  • SHL/SHR: Byte1는 0(미사용)

6) 예시(헥사 덤프 포함)
표기: “B0 B1  ; 설명”  (B0/B1은 16진 2자리)

6.1 대입/이동
  a = 5          → MOVI a, #5
    B0=0x34, B1=0x05    ; OP=3(MOVI), DST=a(0x4), IMM8=0x05

  a = -1         → MOVI a, #-1
    B0=0x34, B1=0xFF    ; -1의 8비트 표현

  d = a          → MOV d, a
    B0=0x26, B1=0x04    ; OP=2(MOV), DST=d(0x6), SRC=a(0x4)

6.2 산술(레지스터-레지스터/즉시)
  a = a + 1      → ADDI a, #1
    B0=0x54, B1=0x01    ; OP=5(ADDI), DST=a

  a = a + d      → ADD a, d
    B0=0x44, B1=0x06    ; OP=4(ADD),  DST=a, SRC=d

  x = x - 1      → SUBI x, #1
    B0=0x78, B1=0x01    ; OP=7(SUBI), DST=x(0x8)

  x = x - a      → SUB x, a
    B0=0x68, B1=0x04    ; OP=6(SUB),   DST=x, SRC=a

6.3 비트 연산
  d = d & a      → AND d, a
    B0=0x86, B1=0x04

  d = d | a      → OR d, a
    B0=0x96, B1=0x04

  d = d ^ a      → XOR d, a
    B0=0xA6, B1=0x04

6.4 시프트/비교
  SHL a          → SHL a
    B0=0xB4, B1=0x00

  SHR a          → SHR a
    B0=0xC4, B1=0x00

  CMP a, d       → CMP a, d    ; a-d 결과로 Z/N/V/C 갱신(결과 저장 없음)
    B0=0xD4, B1=0x06

  CMPI a, #-3    → CMPI a, #-3
    B0=0xD4, B1=0xFD    ; -3 = 0xFD

6.5 분기/점프
  BEQ loop       → Z=1이면 loop로 분기(상대 오프셋)
    가정: 현재 분기 인스트럭션 주소 = 0x04, loop 라벨 주소 = 0x00
    다음 PC(분기 다음) = 0x06 → 오프셋 = 0x00 - 0x06 = -6 = 0xFA
    B0=0xF0, B1=0xFA    ; OP=F(BR), COND=0(BEQ), REL8=0xFA

  BNE +4바이트 앞으로  → 오프셋 = +4 = 0x04
    B0=0xF1, B1=0x04    ; COND=1(BNE)

  JMP 0x20       → 절대 주소 0x20으로 점프
    B0=0xE0, B1=0x20

  HALT           → 종료
    B0=0x10, B1=0x00

7) IR(F1~F12) LED 표시와의 대응(혼합 모드)
- F1,F2: OP 4비트(2비트×2키, 4색) = OP[3:2]→F1, OP[1:0]→F2
- F3,F4: DST 4비트(2비트×2키, 4색) = DST[3:2]→F3, DST[1:0]→F4
- F5~F12: ARG 8비트(1비트×8키, ON/OFF)
- 팔레트는 역할별로 명확히 구분(Teal=OP, Copper=DST, Periwinkle=ARG)하여 가시성을 높임.

8) 어셈블(2패스) 개요
- 패스1: 각 라인의 라벨 주소(바이트 주소)를 수집. 모든 명령어는 2바이트이므로 주소는 0,2,4,…
- 패스2: (OP,DST,ARG)를 확정하고 바이트로 인코딩. 분기는 REL8 = target - (pc+2) 적용.
- 출력: 바이트 배열(또는 헥사 문자열). 예) [0x34,0xFF, 0x54,0x01, 0x10,0x00]

9) 미묘한 부분/주의점
- 즉시값은 8비트 래핑(2의 보수). 예: 130 → 0x82 → 실행 시 -126으로 보일 수 있음.
- CMP/CMPI는 결과 저장 없이 Z/N/V/C만 갱신.
- SUB/CMPI에서 C는 no-borrow 정의(빌림 없으면 1, 빌림 발생 시 0).
- 마이크로옵(ADD8/SUB8/UNPACK/LOADI8_BITS 등)은 교육용/시각화용이며 실제 기계어로 직접 노출하지 않아도 됩니다. 필요 시 상위 OP에 폴드하거나 NOP(0x0) 클래스로 간주.

10) 짧은 디모 프로그램(헥사)
소스:
  a = -1
  a = a + 1
  x = 0
  x = x - 1
  HALT

어셈블:
  MOVI a,#-1  → 34 FF
  ADDI a,#1   → 54 01
  MOVI x,#0   → 38 00
  SUBI x,#1   → 78 01
  HALT        → 10 00

11) 향후 확장 여지
- OP 공간 0x0/일부 예약 코드를 확장: 메모리 접근, I/O, 시스템 콜 등
- ARG 해석 모드 확장: 일부 OP에서 Byte1을 [SRC|MODE] 등으로 재해석
- 16비트 즉시(확장 인스트럭션) 필요 시 프리픽스 코드 도입

본 사양은 현재 리포지토리의 IR 표시 유틸(혼합 2비트/1비트 모드)과 일관되도록 고안되었습니다. 실제 어셈블러/로더를 구현하면서 세부 값은 조정될 수 있습니다.

