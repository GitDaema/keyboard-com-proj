이 문서는 현재 어셈블리 형태 명령어가 2바이트(16비트) 기계어로 매핑되는 규칙을 사람 친화적으로 정리한 사양 초안입니다.
본 문서는 현재 리포지토리의 실제 구현(시뮬레이터/IR 표시 로직)에 맞춘 최신 사양입니다.
주의: 현재 시스템은 ‘표시용 2바이트 인코딩(ENC)’만 생성하여 IR(F1~F12)에 점등하며,
실제 바이너리 어셈블/로더는 아직 구현되어 있지 않습니다.

1) 개요
- 표시용 2바이트(16비트) 인코딩을 사용합니다.
- PC는 “실행 가능한 소스 라인 인덱스”로 동작하며, 기본적으로 +1씩 증가합니다
  (라벨 전용 줄은 주소를 차지하지 않음. 분기/점프 시 PC를 라벨 주소로 덮어씀).
- 표시용 인코딩(단일 포맷):
  • Byte0 = [OP(상위 4비트) | DST(하위 4비트)]
  • Byte1 = ARG(하위 8비트)
- 해석 규칙은 OP에 의해 결정되며, Byte1(ARG)은 현재 시스템에서
  “조건 코드(분기)” 또는 “즉시값/소스 변수 ID”로 사용됩니다.
- 변수 이름은 4비트 ID로 맵핑합니다(표 2 참조).

2) 변수(레지스터) ID 맵
- 4비트(0~15) ID로 고정. 프로젝트 기본값(변경 가능):
  q=0x0, w=0x1, e=0x2, r=0x3, a=0x4, s=0x5, d=0x6, z=0x7, x=0x8

3) OP 코드(4비트) 배정표(표시용 인코딩 기준)
- OP는 상위 4비트에 배치됩니다.
  0x0: NOP(또는 기타 표시 전용 마이크로옵)
  0x1: HALT
  0x2: MOV   (ARG=SRC 변수ID)
  0x3: MOVI  (ARG=IMM8)
  0x4: ADD   (ARG=SRC 변수ID)
  0x5: ADDI  (ARG=IMM8)
  0x6: SUB   (ARG=SRC 변수ID)
  0x7: SUBI  (ARG=IMM8)
  0x8: AND   (ARG=SRC 변수ID)
  0x9: OR    (ARG=SRC 변수ID)
  0xA: XOR   (ARG=SRC 변수ID)
  0xB: SHL   (ARG=0)
  0xC: SHR   (ARG=0)
  0xD: CMP/CMPI (ARG=SRC 변수ID 또는 IMM8)
  0xE: JMP   (ARG=0)           ; 표시용으로 주소/오프셋 미사용
  0xF: BR    (ARG[7:6]=조건 2비트) ; 표시용으로 오프셋 미사용, DST=0

4) 분기군(0xF)의 조건 코드(표시용: ARG 상위 2비트)
- 현재 시스템에서는 DST에 조건 코드를 담지 않습니다. 분기류는 DST=0으로 두고,
  ARG의 최상위 2비트(ARG[7:6])에 ‘조건 클래스(2비트)’만 표시합니다.
- 2비트 한정으로 인해 조건들이 다음과 같이 묶여 표현됩니다.
  • 00b: BEQ, BVC  (둘 다 00으로 동일 표시)
  • 01b: BNE, BVS
  • 10b: BPL, BCC
  • 11b: BMI, BCS
- 분기 오프셋/목적지는 표시용 인코딩에 포함되지 않으며, 실제 실행은 라벨 주소를 직접 PC에 반영합니다.

5) 오퍼랜드 규칙(요약, 현재 시스템 기준)
- 공통: Byte0 하위 4비트(DST)는 ‘대상 변수의 4비트 ID’만 담습니다. 분기/점프처럼 대상 변수가 없는 경우 DST=0.
- 공통: Byte1(ARG)=8비트는 OP에 따라 다음 역할을 가집니다.
  • MOV/ADD/SUB/AND/OR/XOR/CMP: ARG[3:0] = SRC 변수 ID, ARG[7:4] = 0
  • MOVI/ADDI/SUBI/CMPI: ARG = IMM8(2의 보수, signed)
  • BR(분기): ARG[7:6] = 조건 클래스(2비트), 나머지 비트는 0
  • JMP: ARG = 0 (표시용)
  • SHL/SHR: ARG = 0 (표시용)

6) 예시(헥사 덤프 포함)
표기: “B0 B1  ; 설명”  (B0/B1은 16진 2자리)

6.1 대입/이동
  a = 5          → MOVI a, #5
    B0=0x34, B1=0x05    ; OP=3(MOVI), DST=a(0x4), IMM8=0x05

  a = -1         → MOVI a, #-1
    B0=0x34, B1=0xFF    ; -1의 8비트 표현

  d = a          → MOV d, a
    B0=0x26, B1=0x04    ; OP=2(MOV), DST=d(0x6), SRC=a(0x4)

6.2 산술(레지스터-레지스터/즉시)
  a = a + 1      → ADDI a, #1
    B0=0x54, B1=0x01    ; OP=5(ADDI), DST=a

  a = a + d      → ADD a, d
    B0=0x44, B1=0x06    ; OP=4(ADD),  DST=a, SRC=d

  x = x - 1      → SUBI x, #1
    B0=0x78, B1=0x01    ; OP=7(SUBI), DST=x(0x8)

  x = x - a      → SUB x, a
    B0=0x68, B1=0x04    ; OP=6(SUB),   DST=x, SRC=a

6.3 비트 연산
  d = d & a      → AND d, a
    B0=0x86, B1=0x04

  d = d | a      → OR d, a
    B0=0x96, B1=0x04

  d = d ^ a      → XOR d, a
    B0=0xA6, B1=0x04

6.4 시프트/비교
  SHL a          → SHL a
    B0=0xB4, B1=0x00

  SHR a          → SHR a
    B0=0xC4, B1=0x00

  CMP a, d       → CMP a, d    ; a-d 결과로 Z/N/V/C 갱신(결과 저장 없음)
    B0=0xD4, B1=0x06

  CMPI a, #-3    → CMPI a, #-3
    B0=0xD4, B1=0xFD    ; -3 = 0xFD

6.5 분기/점프(표시 전용 인코딩)
  BEQ loop       → DST=0, ARG[7:6]=00
    B0=0xF0, B1=0x00    ; OP=F(BR), CLASS=00(BEQ/BVC)

  BNE somewhere  → DST=0, ARG[7:6]=01
    B0=0xF0, B1=0x40    ; CLASS=01(BNE/BVS)

  BPL label      → DST=0, ARG[7:6]=10
    B0=0xF0, B1=0x80    ; CLASS=10(BPL/BCC)

  BMI label      → DST=0, ARG[7:6]=11
    B0=0xF0, B1=0xC0    ; CLASS=11(BMI/BCS)

  JMP somewhere  → DST=0, ARG=0x00 (표시용으로 주소 미표시)
    B0=0xE0, B1=0x00

  HALT           → 종료
    B0=0x10, B1=0x00

7) IR(F1~F12) LED 표시 매핑(통합 1비트/2비트 혼합)
- 목적: 2바이트(16비트)를 12키로 직관적으로 표현. OP/DST는 비트 단위(ON/OFF), ARG는 2비트 쌍(4색)으로 가독성 향상.
- F1~F4: OP 니블 4비트(상→하) = OP[3]→F1, OP[2]→F2, OP[1]→F3, OP[0]→F4
  • 1비트 표시(ON/OFF), 팔레트 IR_ONOFF["OP"] 사용(ON=시안, OFF=블랙)
- F5~F8: DST 니블 4비트(상→하) = DST[3]→F5, DST[2]→F6, DST[1]→F7, DST[0]→F8
  • 1비트 표시(ON/OFF), 팔레트 IR_ONOFF["DST"] 사용(ON=오렌지, OFF=블랙)
- F9~F12: ARG 바이트 4쌍(2비트×4) = ARG[7:6]→F9, ARG[5:4]→F10, ARG[3:2]→F11, ARG[1:0]→F12
  • 2비트 4상 표시, ARG 전용 팔레트(00=레드, 01=앰버, 10=시안, 11=바이올렛)

주의(분기 표시 규칙):
- ISA 관점: 분기군(OP=0xF)의 조건 코드는 DST 하위 4비트에 들어갑니다(섹션 4 참조).
- 현재 IR/콘솔 ENC 출력은 시각화를 단순화하기 위해 “표시 전용”으로 조건 코드를 ARG의 최상위 2비트(ARG[7:6])에 배치하고, DST는 0으로 둡니다. 실제 메모리 상 인코딩과 다를 수 있으니 혼동 주의.

간단 예시(표시 관점):
- ADDI a,#1  → OP=0x5(0101), DST=a=0x4(0100), ARG=0x01(0000 0001)
  • F1..F4 = 0,1,0,1  • F5..F8 = 0,1,0,0  • F9..F12 = 00,00,00,01(마지막 F12=Green)


8) 프로그램 어드레싱/실행(현재 구현)
- ProgramMemory는 라벨 전용 줄을 제거하고 실행 가능한 라인 배열을 만듭니다.
- PC는 이 배열의 인덱스로 동작하며, 일반적으로 +1 증가합니다.
- 분기/점프는 라벨을 해석해 PC를 해당 인덱스로 직접 설정합니다(오프셋 계산 없음).
- 콘솔에는 현재 라인에 대한 표시용 인코딩이 ENC xxxx xxxx xxxx xxxx 형태로 출력되며,
  IR(F1~F12) 역시 같은 (OP,DST,ARG)로 점등됩니다.

9) 미묘한 부분/주의점
- 즉시값은 8비트 래핑(2의 보수). 예: 130 → 0x82 → 실행 시 -126으로 보일 수 있음.
- CMP/CMPI는 결과 저장 없이 Z/N/V/C만 갱신.
- SUB/CMPI에서 C는 no-borrow 정의(빌림 없으면 1, 빌림 발생 시 0).
- 마이크로옵(ADD8/SUB8/UNPACK/LOADI8_BITS 등)은 교육용/시각화용이며 실제 기계어로 직접 노출하지 않아도 됩니다. 필요 시 상위 OP에 폴드하거나 NOP(0x0) 클래스로 간주.

10) 짧은 디모 프로그램(표시용 ENC 예시)
소스:
  a = -1
  a = a + 1
  x = 0
  x = x - 1
  HALT

표시용 인코딩(ENC):
  MOVI a,#-1  → B0=34, B1=FF   ; OP=3, DST=a(4), ARG=FF
  ADDI a,#1   → B0=54, B1=01   ; OP=5, DST=a(4), ARG=01
  MOVI x,#0   → B0=38, B1=00   ; OP=3, DST=x(8), ARG=00
  SUBI x,#1   → B0=78, B1=01   ; OP=7, DST=x(8), ARG=01
  HALT        → B0=10, B1=00   ; OP=1, DST=0, ARG=00

11) 향후 확장 여지
- OP 공간 0x0/일부 예약 코드를 확장: 메모리 접근, I/O, 시스템 콜 등
- ARG 해석 모드 확장: 일부 OP에서 Byte1을 [SRC|MODE] 등으로 재해석
- 16비트 즉시(확장 인스트럭션) 필요 시 프리픽스 코드 도입

본 사양은 현재 리포지토리의 코드와 일치합니다(표시용 ENC + IR 점등).
향후 실제 어셈블러/로더를 도입할 때 분기 오프셋/절대주소 등 세부 포맷은 달라질 수 있습니다.
